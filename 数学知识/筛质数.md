## 筛质数

给定一个正整数 $n$ ，请你求出 $1 {\sim} n$ 中质数的个数。

## 解题思路

### 普通做法

我们可以构建出一个长度为 $n+1$ 的 bool 型数组 $prime$，true表示数 $i$ 不是素数，false表示数 $i$ 是素数。

我们知道 2 一定是素数，接下来我们就可以遍历小于等于 $n$ 的数，如果它能被 2 整除，那么它一定不是素数。

我们把这些数在 $prime$ 中置为true.

如此，从 $2 \sim n$ 遍历即可。

**时间复杂度**

> $\frac{n}{2} + \frac{n}{3} + \dotsm + \frac{n}{n}$ = $n\times (\frac{1}{2} + \frac{1}{3} + \dotsm + \frac{1}{n})$ = $n\ln_{}{n}$

### 埃氏筛法
进一步优化，可以不用遍历 $2 \sim n$ ，只需要遍历 $2 \sim n$ 其中的质数。

当一个数不是质数时，就不用再去筛选看它的倍数了。

这是因为：**合数是质因数之积**。

**时间复杂度**

> $O(n \log_{}{\log_{}{n}})$

### 欧式筛法

**核心点：每个合数只会被其最小质因子筛掉**

在埃氏筛法中，一个合数来说可能会被筛多次，比如6可以被2筛去，也可以被3筛去，而欧拉筛要做的事情就是让一个合数只被筛一次。

当数 $num$ 可以整除质数 $p_i$ 时，就直接break，不用去看下一个质数 $p_{i+1}$ 了

因为 $p_{i+1} > p_i$ ，由上可知， $num=p_i \times k$ （ $k$ 为常数）

我们假设 $p_{i+1} \times num=X$ ，代入上式，进一步有 $p_{i+1} \times (p_i\times k)=X$

$X=(p_{i+1} \times k) \times p_i$

我们如果用 $p_i$ 去筛选 $X$ 的话，此时的 $num=p_{i+1} \times k$.

如果用 $p_{i+1}$ 去筛选 $X$ 的话，此时的 $num=p_{i} \times k$.

为了保证合数只被筛掉一次，我们就要让它被最小质因子筛掉，也就意味着要乘以最大的倍数也就是更大的 $num$.

> eg: 18以内的质数
>
> 第一次循环，2为质数，筛选掉4，此时2(num)%2(prime[0])=0，break
>
> 第二次循环，3为质数，筛选掉6、9
>
> 第三次循环，4，不是质数，筛选掉8，4｜2，break
>
> 第四次循环，5，是质数，筛选掉10，15
>
> 第五次循环，6，不是质数，筛选掉12，6｜2，break
>
> 第六次循环，7，是质数，筛选掉14
>
> 第七次循环，8，不是质数，筛选掉16，8｜2，break
>
> $\dotsm$

```cpp
#include <iostream>
using namespace std;

const int N = 1000010;
bool prime[N]; // true表示不是素数，false表示是素数，初始化为false

int normal_select(int n) {
    int count = 0;
    for (int i = 2; i <= n; i++) {
        // 当我们遍历到i时，它一定被试过是否为素数了，因为我们是i*j一直到n的
        if (!prime[i]) {
            count++;
        }
        int j = 2;
        while (j <= n / i) {
            prime[i * j] = true;
            j++;
        }
    }
    return count;
}

int aishi_select(int n) {
    int count = 0;
    for (int i = 2; i <= n; i++) {
        if (!prime[i]) { // i为质数
            count++;
            int j = 2;
            while (j <= n / i) {
                prime[i * j] = true;
                j++;
            }
        }
    }
    return count;
}

int oushi_select(int n) {
    int count = 0;
    int nums[N]; // 这个数组用来存储质数
    for (int i = 2; i <= n; i++) {
        if (!prime[i]) { // i为质数
            nums[count++] = i; // 把质数存储到数组里
        }
        for (int j = 0; nums[j] <= n / i; j++) {
            prime[nums[j] * i] = true; // 质数的i倍是合数
            if (i % nums[j] == 0) { // 当前i可以整除此质数时，break
                break;
            }
        }
    }
    return count;
}

int main()
{
    int n;
    cin >> n;
    printf("%d", oushi_select(n));
    return 0;
}
```