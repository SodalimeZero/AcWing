## 最大流

令 $G=(V,E)$ 是一个有源汇点的网络，我们希望在 $G$ 上指定合适的流 $f$，以最大化整个网络的流量 $|f|$（即 $\sum_{x \in V} f(s, x) - \sum_{x \in V} f(x, s)$），这一问题被称作最大流问题（Maximum flow problem）。

### Ford–Fulkerson 增广

该方法使用了**贪心算法** 

#### 算法步骤

1. **初始化**：

   对于每条边 $e \in E$ ，初始流量 $f(e) = 0$

2. **寻找增广路径**：

   在残余网络 $G_f$ 中，找到一条从源点 s 到汇点 t 的增广路径 P

3. **沿增广路径增加流量**：

   - 计算路径 P 的瓶颈容量（即路径上所有边的最小剩余容量）。

   - 沿增广路径 P 增加瓶颈容量的流量，同时更新反向边的流量。

4. **重复**：

   重复步骤2和3，直到在残余网络中找不到从源点 s 到汇点 t 的增广路径为止。

#### 伪代码

```
FOREACH edge e ∈ E : f (e) ← 0.
Gf ← residual network of G with respect to flow f.
WHILE (there exists an s↝t path P in Gf )
	f ← AUGMENT(f, c, P).
	Update Gf.
RETURN f.
```

### 最大流-最小割定理

最大流的值等于最小割的容量。

**增广路径定理**：当且仅当不存在增广路径时，流 $f$ 是最大流。

### 证明

任意流 $f$ 满足以下三个条件，且这三个条件相互等价：

1. **存在一个割 $(A, B)$，使得割的容量等于流的值**：
   
    $\text{cap}(A, B) = \text{val}(f)$ 
   
2. **流 $f$ 是最大流**：
    $f \text{ 是最大流}$ 

3. **不存在增广路径**：
   相对于 $f$ ，不存在增广路径

### 增广路径的选择

#### 1. Capacity-scaling算法

```
FOREACH edge e ∈ E : f (e) ← 0.
Δ ← largest power of 2 ≤ C.

WHILE (Δ ≥ 1)
	Gf (Δ) ← Δ-residual network of G with respect to flow f .
	WHILE (there exists an s↝t path P in Gf (Δ))
		f ← AUGMENT(f, c, P).
		Update Gf (Δ).
	Δ ← Δ / 2. 
RETURN f.
```

时间复杂度： $ O(m^2\log C) $

#### 2. 最短增广路径

##### 层次图

在有向图 $G=(V, E)$ 中，源点为 s，其层次图（level graph）是一种特殊的子图，它根据从源点 s 到图中其他顶点的最短路径的边数来定义。

<img src="../images/level graph.png" style="zoom:30%;margin-left: 0" />

#### 3. Dinitz算法

时间复杂度 $O(mn^2)$

伪代码

```c++
INITIALIZE(G, f) // 初始化最大流算法
    LG ← level-graph of Gf // 通过广度优先搜索（BFS）构建层次图
    P ← ∅ // 初始化增广路径为空
    GOTO ADVANCE(s) // 从源点开始

RETREAT(v) 
    IF (v = s) // 只剩下源点，算法停止
        STOP 
    ELSE
        Delete v (and all incident edges) from LG // 在层次图中删除这个点以及所有邻接边
        Remove last edge (u, v) from P // 从路径P中移除最后一条边
        GOTO ADVANCE(u) // 返回前一个节点继续尝试其他路径

ADVANCE(v) 
    IF (v = t) // 当前节点为汇点，找到增广路径
        AUGMENT(f, P) // 增广流量
        Remove saturated edges from LG // 从层次图中移除已饱和的边
        P ← ∅ // 重置路径P为空
        GOTO ADVANCE(s) // 从源点重新开始寻找新的增广路径

    IF (there exists edge (v, w) ∈ LG) // 如果在层次图中存在边(v, w)
        Add edge (v, w) to P // 将边(v, w)添加到路径P中
        GOTO ADVANCE(w) // 继续前进到节点w
    ELSE
        GOTO RETREAT(v) // 没有更多可走的边，回退

AUGMENT(f, P) // 增广路径
    δ ← bottleneck capacity of augmenting path P // 找到增广路径P中的瓶颈容量
    FOREACH edge e ∈ P // 对路径P中的每一条边
        IF (e ∈ E) 
            f(e) ← f(e) + δ // 如果边e在原图中，则增加流量
        ELSE 
            f(e_reverse) ← f(e_reverse) – δ // 如果边e是反向边，则减少流量
    RETURN f // 返回更新后的流量
```

##### 算法步骤

1. **构建分层网络**：使用广度优先搜索（BFS）构建一个层次图（分层网络），其中源点位于第0层，后续层次逐层增加，汇点位于某一层。在层次图中，从层次i到层次i+1有容量的边被保留，其他边被忽略。
2. **增广路径查找**：在分层网络中使用深度优先搜索（DFS）查找增广路径，即从源点到汇点的一条路径，使得沿路径上的每条边都有剩余容量。找到增广路径后，将沿路径的最小剩余容量（瓶颈容量）作为增广流量添加到该路径上。
3. **流量更新**：更新网络中所有边的容量，减去增广路径上的瓶颈容量。如果有反向边，则增加相应的容量。
4. **重复构建分层网络和增广路径查找**：在每一轮迭代中重复步骤1到3，直到无法在分层网络中找到增广路径为止。

##### 单位容量网络

对于网络 $𝐺=(𝑉,𝐸)$，如果其所有边容量均为 1，所有的中间点或者入度为1或者出度为1，则我们称 $𝐺$ 是单位容量（Unit Capacity）的。

**证明：对于单位容量网络，Dinic算法在 $O(n^{1/2}m)$ 步内结束计算**

1. 在单位容量的网络中，Dinic 算法的单轮增广的时间复杂度为 $O(m)$ 

   > 这是因为，每次增广都会导致增广路上的所有边均饱和并消失，故单轮增广中每条边只能被增广一次。

2. 若最大流量 $v^* \le n^{1/2}$ ，则显然最多有 $n^{1/2}$ 个阶段

3. 若 $v^* \ge n^{1/2}$ ，那么之后也最多有 $n^{1/2}$ 个阶段，总阶段数不超过 $2n^{1/2}+1$ . 