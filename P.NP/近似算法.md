## 近似算法

### 顶点覆盖问题

给定一个图 $G$，可以找到一个顶点覆盖，其顶点数量不超过最优解顶点数量的两倍（即 $\leq 2 \times \text{OPT}$ ）

这个算法在 $O(m + n)$ 时间内运行，其中 $m$ 是边数，$n$ 是顶点数。

最小顶点覆盖问题：任给一个图 $G=<V,E>$ ，求 $G$ 的顶点数最少的顶点覆盖

#### 伪代码

<img src="/Users/xblock/Library/Application Support/typora-user-images/image-20240623204056381.png" alt="image-20240623204056381" style="zoom: 33%; margin-left: 0" />

流程：

1. 开始时令 $S=\varnothing$ 
2. 任取一条边 $(u,v)$ ，把节点 $u,v$ 加入 $S$ 并删去这两个节点及其所关联的边
3. 重复上述过程直到删去所有的边
4. 输出 $S$ 即为所求的顶点覆盖

> 贪心算法提供了一个有效的 2-近似算法来解决顶点覆盖问题，证明了找到的顶点覆盖集的大小不超过最小顶点覆盖集的两倍。

#### 定理

设 $S^*$ 为最小顶点覆盖。贪心算法计算的顶点覆盖 $S$ 满足 $|S| \leq 2|S^*|$ 

**证明**：

1. $S$ 是一个顶点覆盖，因为算法保证每次选择的边的两个端点都被添加到 $S$ 中，确保所有边都被覆盖
2. 设 $M$ 为算法中选择的边集（即匹配）
3. 在每次迭代中，贪心算法选择一条边并将其两个端点加入 $S$，因此 $|S| = 2|M|$
4. 根据匹配的性质，最小顶点覆盖集 $S^*$ 必须至少包含匹配中每条边的一个端点，即 $|S^*| \geq |M|$
5. 因此 $|S| = 2|M| \leq 2|S^*|$

所以，贪心算法找到的顶点覆盖大小是最小顶点覆盖大小的两倍以内

#### 推论

设 $M^*$ 为最大匹配。贪心算法计算的匹配 $M$ 满足 $|M|\geq \frac{1}{2}|M^*|$

**证明**：

1. 根据顶点覆盖定理的证明，贪心算法找到的匹配 $M$ 满足 $|S| = 2|M|$
2. 根据顶点覆盖的性质，最小顶点覆盖集 $S^*$ 的大小是 $|S^*| \geq |M^*|$，因为一个最小顶点覆盖必须覆盖所有匹配的边。
3. 因此，贪心算法找到的顶点覆盖 $S$ 满足 $|S| \leq 2|S^*|$
4. 从这里可以推导出 $|M| = \frac{1}{2}|S|$，所以 $|M|\geq \frac{1}{2}|M^*|$

这个推论表明，贪心算法找到的匹配大小至少是最大匹配大小的一半。

### 背包问题

给定一个集合 $X$，每个元素的权重 $w_i$ 和价值 $v_i$ ，一个重量限制 $W$，以及一个目标价值 $V$

是否存在一个子集 $S \subseteq X$ ，使得这个子集的元素的总重量不超过 $W$，且总价值至少为 $V$ ？

#### 动态规划1

$OPT(i,w)$表示在重量限制为 $W$ 的情况下，前 $i$ 个物品的最大价值

<img src="/Users/xblock/Library/Application Support/typora-user-images/image-20240623210734165.png" alt="image-20240623210734165" style="zoom:33%; margin-left: 0" />

时间复杂度为 $O(nW)$

#### 动态规划2

定义动态规划状态 $\text{OPT}(i, v)$ 表示在使用前 $i$ 个物品的情况下，取得价值至少为 $v$ 的解决方案所需的最小重量。

找到最大的 $v$ ，使得 $\text{OPT}(n, v) \leq W$ ，其中 $n$ 是物品总数， $W$ 是背包的最大承重。

我们考虑两种情况来递归地定义 \( $\text{OPT}(i, v)$ \)：

1. **不选择第 $i$ 个物品**：
   - 最优解在前 $i-1$ 个物品中选择，使得取得的价值至少为 $v$ 
   - 因此，$\text{OPT}(i, v) = \text{OPT}(i-1, v)$

2. **选择第 $i$ 个物品**：
   - 消耗重量 $w_i$ ，需要在前 $i-1$ 个物品中选择，使得取得的价值至少为 $v - v_i$ 
   - 因此，$\text{OPT}(i, v) = w_i + \text{OPT}(i-1, v-v_i)$ 

<img src="../images/beibao2.png" alt="image-20240623212032512" style="zoom: 40%; margin-left: 0" />

##### 算法复杂度分析

1. **最大值 $V^*$**：
   - 最优值 $V^*$ 不会超过 $n \times \text{v}_{max}$ ，其中 $\text{v}_{max}$ 是任一物品的最大价值。

2. **子问题数量**：
   - 每个物品 $i$ 和每个价值 $v$ 构成一个子问题，总共有 $n \times V^*$ 个子问题。

3. **子问题计算时间**：
   - 计算每个子问题需要 $O(1)$ 时间。

因此，总时间复杂度为 $O(n \times V^*) = O(n^2 \times \text{v}_{max})$ 

### 近似比

设 $OPT(I)$ 表示实例 $I$ 的最优解的值

