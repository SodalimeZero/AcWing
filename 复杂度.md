### 暴力求解（Brute Force）



### 多项式运行时间

我们通常认为具有多项式运行时间的算法是高效的。

**可取的扩展属性：**当输入大小翻倍时，算法的运行时间应该最多只增加一个乘法常数因子 $C$ 

**定义：**如果上述扩展属性成立，即算法的运行时间与输入大小的多项式成正比，则称该算法具有多项式时间复杂度。

**形式化定义：**存在正常数 $a>0$ 和 $b>0$ ，使得对于每个大小为 $n$ 的输入，算法执行的原始计算步骤数量满足： 步骤数 $≤𝑎⋅𝑛^𝑏$

### 时间复杂度（$O$）

#### 常数倍数
- 如果 \( f \) 是 \( O(g) \) 并且 \( c > 0 \)，那么 \( c \cdot f \) 也是 \( O(g) \)。大O表示法忽略了常数因子，因此乘以一个正常数不会改变 \( f \) 的时间复杂度类别。

#### 乘积
- 如果 $f_1$ 是 $O(g_1)$ 并且 $f_2$ 是 $O(g_2)$，那么 $f_1 \cdot f_2$ 是 $O(g_1 \cdot g_2)$
  - **证明**：根据 $f_1$  和 $f_2$  的定义，存在 $c_1 > 0$ 和 $n_1$ 使得 $ 0 \leq f_1(n) \leq c_1 \cdot g_1(n)$ 对所有 $ n \geq n_1$ 成立；存在 $c_2 > 0$ 和 $n_2$ 使得 $0 \leq f_2(n) \leq c_2 \cdot g_2(n)$ 对所有 $n \geq n_2$ 成立
  
    因此，对于所有 $ n \geq \max\{n_1, n_2\}$ ，有$0 \leq f_1(n) \cdot f_2(n) \leq (c_1 \cdot c_2) \cdot g_1(n) \cdot g_2(n)$
    这表明 $f_1 \cdot f_2$ 的增长速率最多是 $g_1 \cdot g_2$ 的 $c_1 \cdot c_2$ 倍

#### 和
- $f_1 + f_2$ 是 $O(\max\{g_1, g_2\})$ 这意味着两个函数的和的增长速率最多与这两个函数中增长最快的那个相同。

### $\Omega $ 表示法

#### 典型用法

任何基于比较的排序算法在最坏情况下至少需要 $\Omega(𝑛\log⁡𝑛)$ 次比较。这是由于比较排序的最低下界定理，它指出了任何比较排序算法必须执行的最小比较次数。

#### 特点

- **忽略高阶项**：在大Ω表示法中，我们关注 𝑓(𝑛) 的最低次项，以确定算法的最小性能。
- **忽略常数因子**：与大O表示法类似，大Ω表示法也忽略了常数因子，因为它们不影响算法的渐进下界。
- **非精确量度**：大Ω表示法提供了一种算法性能的下界估计，而不是精确的量度。

### 大 Θ 符号

对于函数 𝑓(𝑛) 和 𝑔(𝑛)，$f(n)=\Theta(g(n))$，当且仅当 $\exists \ c_1, c_2, n_0 > 0$  ，使得 $\forall n \ge n_0, 0 \le c_1 \cdot g(n) \le f(n) \le c_2 \cdot g(n)$ 

也就是说，如果函数 $f(n)=\Theta(g(n))$ ，那么我们能找到两个正数 $c_1, c_2$ 使得 𝑓(𝑛) 被 $c_1 \cdot g(n)$ 和 $c_1 \cdot g(n)$ 夹在中间。

例如，$3n^2+5n-3=\Theta(n^2)$, 这里的 $c_1, c_2, n_0$ 可以分别是 2,4,100

$n\sqrt {n} + n{\log^5 n} + m{\log m} +nm=\Theta(n\sqrt {n} + m{\log m} + nm)$，这里的 $c_1, c_2, n_0$ 可以分别是 1,2,100

### 常数时间

通常表示为$O(1)$ 

条件分支（if-else)、算术/逻辑操作、声明变量、访问链表/数组、比较/交换数组中的元素

### 线性时间

算法的运行时间与输入数据的规模成线性关系，即 $O(n)$ ，其中 $n$ 是输入数据的个数。

两个有序列表合并、归并排序中的合并操作

**例题**

给定一个包含 $n$ 个不同整数的有序数组，以及一个整数 $T$ ，找出数组中的两个数，它们的和正好等于 $T$ 

$O(n^2)$ 算法：

- **方法**：尝试所有可能的数对组合，直到找到两个数的和等于 $T$
- **时间复杂度**：需要 $O(n^2)$ ，因为对于数组中的每个元素，我们可能需要与剩下的 $n-1$ 个元素进行配对检查。

$O(n)$ 算法：

- **方法**：利用数组的有序性，使用双指针（或索引）方法。
- **初始位置**：设置两个指针，一个指向数组的起始位置（左指针），另一个指向数组的结束位置（右指针）。
- **调整指针**
  - 如果两个指针所指向的元素之和小于 $T$ ，则移动左指针向右，增加当前值。
  - 如果两个指针所指向的元素之和大于 $T$ ，则移动右指针向左，减少当前值。
  - 如果等于 $T$ ，则找到了一对符合条件的数，并且可以返回这两个数。
- **终止条件**：当左指针超过右指针时，结束搜索。

### 对数时间

$O(\log n)$ 

二分搜索

### 线性对数时间

$O(n \log n)$

排序，如归并排序

### 二次时间

$O(n^2)$

### 三次时间

$O(n^3)$ 

3-sum问题：给定一个包含 $n$ 个不同整数的数组，找出数组中的三个数，使它们的和为 0

$O(n^3)$算法：

- 尝试所有三元组
  - 使用三层循环枚举所有可能的三元组 $(i,j,k)$ ，其中 𝑖<𝑗<𝑘
  - 对于每个三元组，检查 $a_i+a_j+a_k$ 是否为0

$O(n^2)$ 算法：

- 排序数组
  - 首先对数组进行排序，时间复杂度为 $O(n\log n)$
- 固定一个元素
  - 对于数组中的每个元素 $a_i$ ，将其固定并从数组中去除
- 解决TARGET-SUM问题
  - 在剩余的数组中使用二分搜索解决TARGET-SUM问题，目标和 $T$ 设为 $-a_i$
  - 对于每个 $a_i$ ，需要在 $O(n\log n)$  时间内找到两个数，它们的和为 $-a_i$

### 多项式时间

$O(n^k)$

给定一个图，找出 $k$ 个节点，使得这 $k$ 个节点之间没有任何两条边相连。