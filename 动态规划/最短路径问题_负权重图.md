## 最短路径问题——负权重图

### 之前算法

##### Dijkstra算法失效

如果图中存在负权重的边，$Dijkstra$ 算法可能无法产生正确的最短路径。

这是因为算法假设一旦确定了从起点到某个顶点的最短路径，就不会再有更短的路径出现。

但在有负权重边的情况下，后续处理的顶点可能会通过负权重边连接到之前已经处理过的顶点，从而改变最短路径。

##### 重新加权方法失败

- **重新加权**：一种尝试解决负权重问题的方法是给所有边的权重加上一个足够大的常数，使得所有边的权重都变为非负，然后应用$Dijkstra$ 算法。

- **问题**：即使所有边的权重都是非负的，这种方法也不能保证 $Dijkstra$ 算法能够产生正确的最短路径。

    原因是加权可能会改变边之间的相对权重，导致原本由于负权重边而形成的最短路径被错误地计算。

### 引理

#### 引理 1：存在负权重环时最短路径不存在

- **描述**：如果从顶点 $v$ 到顶点 $t$ 的某条路径包含了一个负权重环 $W$ ，那么就不存在从 $v$ 到 $t$ 的最短路径。
- **证明**：如果存在这样一个负权重环 $W$ ，那么我们可以通过不断地绕行 $W$ 来构造一个任意负长度的从 $v$ 到 $t$ 的路径。因为每次绕行 $W$ 都会使路径的总权重减少，这意味着路径的权重可以无限减小，所以不存在一个固定的“最短”权重。

#### 引理 2：无负权重环时存在简单最短路径

- **描述**：如果图 $G$ 中没有负权重环，那么存在一条从 $v$ 到 $t$ 的最短路径，这条路径是简单的（即不包含环），并且包含的边数不超过 $n - 1$（其中 $n$ 是图中顶点的数量）。

- **证明**：

    - 在所有从 $v$ 到 $t$ 的最短路径中，考虑使用边数最少的那条路径 $P$ 

    - 如果 $P$ 包含一个有向环 $W$ ，我们可以移除 $P$ 中对应 $W$ 的部分而不增加路径的长度。

        因为如果 $W$ 不是负权重环，移除 $W$ 后路径的权重不会增加，这样就得到了一条同样权重但边数更少的路径。

    - 重复这个过程，直到没有环为止，最终得到的路径就是一条简单最短路径。

### 算法流程

**状态转移方程：**

$OPT(i,v)$ ：使用**不超过** $i$ 条边的条件下，从顶点 $v$ 到终点 $t$ 的最短路径的长度

情况 1：最短路径使用不超过 $i-1$ 条边

情况 2：最短路径恰好使用 $i$ 条边。

 $OPT(i,v)=\min \{OPT(i-1,v), \min\{OPT(i-1,w)+ l_{vw}\}\}$

#### 伪代码及解释

```c++
SHORTEST-PATHS(V, E, ℓ, t) 
FOREACH node v ∈ V :
	M [0, v] ← ∞.
M [0, t] ← 0.
FOR i = 1 TO n – 1
	FOREACH node v ∈ V :
		M [i, v] ← M [i – 1, v].
		FOREACH edge (v, w) ∈ E :
			M [i, v] ← min { M [i, v], M [i – 1, w] + ℓvw }
```

#### 步骤

1. **初始化**：
   - 将源节点的距离设为0，其他所有节点的距离设为无穷大。
   - 将所有节点的前驱节点设为 $null$

2. **松弛操作**：
   - 对于每一条边 $(u, v, w)$ ，如果通过 $u$ 到达 $v$ 的路径比当前已知的路径更短（即`dist[u] + w < dist[v]`），则更新`dist[v] = dist[u] + w`，并将v的前驱节点设置为u。
   - 这个操作需要对所有边重复进行 $V-1$ 次，其中 $V$ 是图中的节点数。

3. **检测负权重环**：
   - 再次遍历所有边，如果仍然能够进行松弛操作（即存在`dist[u] + w < dist[v]`），则说明图中存在负权重环。

#### 时间复杂度

Bellman-Ford算法的时间复杂度是 $O(V\times E)$，其中 $V$ 是节点数，$E$ 是边数。这个时间复杂度来自于对每个节点进行 $V-1$ 次松弛操作，每次操作需要遍历所有的边。

### 算法优化

#### 空间优化

使用两个一维数组代替二维数组

- `d[v]`：表示从节点 $v$ 到目标节点 $t$ 的当前已找到的最短路径长度。
- `successor[v]`：表示从节点 $v$ 到目标节点 $t$ 的路径上的下一个节点。

#### 性能优化

1. 提前终止

​	如果在某一轮迭代中，所有节点的最短路径估计值都没有更新，那么说明最短路径已经找到，可以提前终止算法。

2. 跳过未更新节点的边

​	如果在第`i-1`轮迭代中节点`w`的最短路径估计值`d[w]`没有更新，那么在第`i`轮迭代中可以跳过所有以`w`为终点的边。

#### 优化后伪代码

```
BELLMAN–FORD–MOORE(V, E, c, t) 
FOREACH node v ∈ V :
	d[v] ← ∞.
	successor[v] ← null.
d[t] ← 0.
FOR i = 1 TO n – 1
	FOREACH node w ∈ V :
	IF (d[w] was updated in previous pass)
		FOREACH edge (v, w) ∈ E :
			IF (d[v] > d[w] + ℓvw)
				d[v] ← d[w] + ℓvw.
				successor[v] ← w.
	IF (no d[⋅] value changed in pass i) STOP.
```



### 使用场景

1. **处理包含负权重边的图**：这是Bellman-Ford算法相对于Dijkstra算法的主要优势。
2. **检测负权重环**：Bellman-Ford算法能够检测图中是否存在负权重环。

### 引理证明

**在第 $i$ 次遍历之后，$d[v] ≤$ 使用至多 $i$ 条边的从 $v$ 到 $t$ 的最短路径的长度。**

证明：通过对 $i$ 的归纳证明

- 基准情况：$i = 0$
    - 初始化时，$d[v] = ∞$（对于$v ≠ t$），$d[t] = 0$。这显然满足。
- 归纳假设：假设在第 $i$ 次遍历结束时，对于所有节点 $v$ ，都有 $d[v] ≤$ 使用至多 $i$ 条边的从$v$到$t$的最短路径的长度。
- 归纳步骤：考虑任意从v到t的路径P，该路径使用不超过 $i+1$ 条边。
    - 设路径P的第一条边为 $(v, w)$ ，剩余部分P'为从w到t的子路径。
    - 根据归纳假设，在第i次遍历结束时，d[w] ≤ P'的长度，因为P'是一条使用不超过i条边的w到t的路径。
    - 在第 $i+1$ 次遍历中，考虑边 $(v, w)$ 时：$d[v] ≤ ℓ(v, w) + d[w]$ ，其中 $ℓ(v, w)$ 是边 $(v, w)$ 的权重。
    - 因此，$d[v] ≤ ℓ(v, w) + ℓ(P') =$ P的长度。
    - 这表明，在第 $i+1$ 次遍历结束时，d[v] ≤ 使用不超过i+1条边的从v到t的最短路径的长度。