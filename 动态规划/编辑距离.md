### 编辑距离

#### **定义**

针对两个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。

##### 操作类型

1. **插入**：在一个字符串中插入一个字符。
2. **删除**：从一个字符串中删除一个字符。
3. **替换**：将一个字符串中的一个字符替换为另一个字符。

##### 间隔罚分和不匹配罚分

- **间隔罚分 ( $\delta$ )**：插入或删除一个字符的代价。
- **不匹配罚分 ( $\alpha_{pq}$ )**：将字符 $p$ 替换为字符 $q$ 的代价。

#### 动态规划解题思路

##### 状态表示 $dp[i][j]$

集合：所有把 $a$ 中的前 $i$ 个字母变成 $b$ 中前 $j$ 个字母的集合的操作集合
属性：所有操作中操作次数最少的方案的操作数

##### 状态计算

**状态划分**：以对 $a$ 中的第 $i$ 个字母操作不同划分

1. 在该字母之后添加一个字母之后变得相同，说明没有添加前 $a$ 的前 $i$ 个已经和 $b$ 的前 $j-1$ 个已经相同
   $dp[i][j]=dp[i][j-1]+1$
2. 删除该字母
   删除该字母之后变得相同，说明没有删除前 $a$ 中前 $j-1$ 已经和 $b$ 的前 $j$ 个已经相同
   $dp[i][j]=dp[i-1][j]+1$
3. 替换该字母
   替换说明对应结尾字母不同，则看倒数第二个
   $dp[i][j]=dp[i-1][j-1]+1$
4. 啥也不做
   对应结尾字母相同，直接比较倒数第二个
   $dp[i][j]=dp[i-1][j-1]$

综上，有如下的转移方程

$dp[i][j]=\left\{\begin{matrix}
 dp[i][j-1]+1&&添加一个字母后匹配\\
 dp[i-1][j]+1&&删除\\
dp[i-1][j-1]+1&&替换\\
  dp[i-1][j-1]&&match，啥也不做
\end{matrix}\right.$

算法的时间、空间复杂度均为 $O(mn)$ ， $m, n$ 分别为字符串 $a, b$ 的长度

#### Hirschberg算法

降低空间复杂度到 $O(m+n)$

$f(i,j)$ 表示从 $(0,0)$ 走到 $(i,j)$ 的路径

**引理：对于所有的 $i,j$，$f[i][j]=dp[i][j]$**

**证明**

- **基础案例**：$𝑓(0,0)=dp(0,0)=0$

- **归纳假设**：假设对于所有 $𝑖' +𝑗'<𝑖+𝑗$ 的情况，$𝑓(𝑖',𝑗')=dp(𝑖',𝑗')$ 成立。

- **归纳步骤**：考虑到达 $(𝑖,𝑗)$ 的最短路径的最后一个边。

  这个边可以来自三个可能的前一个状态：$(𝑖−1,𝑗−1)$、$(𝑖−1,𝑗)$或 $(𝑖,𝑗−1)$

  这意味着，到达 $(i,j)$ 的最短路径可以通过以下三种操作之一到达：

  1. 从 $(i-1,j-1)$ 替换字符（代价为 $\alpha_{x_i,y_{j}}$ ）
  2. 从 $(𝑖−1,𝑗)$ 删除字符（代价为 $\delta$ ）
  3. 从 $(𝑖,𝑗−1)$ 插入字符（代价为 $\delta$ ）

因此，$𝑓(𝑖,𝑗)$ 可以表示为： $𝑓(𝑖,𝑗)=min⁡\{\alpha_{x_i,y_{j}}+𝑓(𝑖−1,𝑗−1),\delta+𝑓(𝑖−1,𝑗),\delta+𝑓(𝑖,𝑗−1)\}$

根据归纳假设，我们可以将 $f$ 替换为 $dp$ ： $𝑓(𝑖,𝑗)=min⁡\{\alpha_{x_i,y_{j}}+dp(𝑖−1,𝑗−1),\delta+dp(𝑖−1,𝑗),\delta+dp(𝑖,𝑗−1)\}$

$f(i,j)=dp(i,j)$

这证明了引理，即 $𝑓(𝑖,𝑗)$ 确实等于 $𝑂𝑃𝑇(𝑖,𝑗)$ ，对于所有的 $i, j$

**定义 $g(i, j)$ **

- 定义 $g(i, j)$ 为从点 $(i, j)$ 到终点 $(m, n)$ 的最短路径长度
- 通过反转边的方向和交换起点 $(0,0)$ 和终点 $(m, n)$ 的角色，可以计算 $g(i, j)$ 
- 同样，可以计算任意 $j$ 的 $g(\cdot, j)$ ，其时间复杂度和空间复杂度与 $f(\cdot, j)$ 相同

**观察**

1. 使用点 $(i, j)$ 的最短路径长度是 $f(i, j) + g(i, j)$ 
2. 设 $q$ 是使得 $f(q, n / 2) + g(q, n / 2)$ 最小的索引。那么，存在一条从 $(0, 0)$ 到 $(m, n)$ 的最短路径，它通过点 $(q, n / 2)$。

**分治策略**

- **划分（Divide）**：找到索引 $q$ ，使得 $f(q, n / 2) + g(q, n / 2)$ 最小；将节点 $i-j$  作为解决方案的一部分保存下来。
- **合并（Conquer）**：递归地计算每个部分的最优对齐。

##### 算法流程

1. **初始化**：定义 $f(i, j)$  和 $g(i, j)$ ，它们分别代表从**起点到点 $(i, j)$** 和**从点 $(i, j)$ 到终点**的最短路径长度。
2. **计算 $f,g$ **：使用动态规划算法计算 $f(\cdot, j)$ \) 和 \( $g(\cdot, j)$ ，对于每个 $j$
3. **寻找分割点**：在 $f,g$ 的计算结果中，找到使得 $f(q, n / 2) + g(q, n / 2)$ 最小的 $q$ 
4. **递归求解**：将问题分为两部分，一部分是计算从 $(0,0)$ 到 $(q, n/2)$ 的最优对齐，另一部分是计算从 $(q, n/2)$ 到 $(m,n)$ 的最优对齐。递归地解决这两个子问题。
5. **合并结果**：将两个子问题的最优对齐结果合并，得到整个问题的最优对齐。

#### 最短路径问题——负权重图

##### Dijkstra算法失效

如果图中存在负权重的边，$Dijkstra$ 算法可能无法产生正确的最短路径。

这是因为算法假设一旦确定了从起点到某个顶点的最短路径，就不会再有更短的路径出现。

但在有负权重边的情况下，后续处理的顶点可能会通过负权重边连接到之前已经处理过的顶点，从而改变最短路径。

##### 重新加权方法失败

- **重新加权**：一种尝试解决负权重问题的方法是给所有边的权重加上一个足够大的常数，使得所有边的权重都变为非负，然后应用$Dijkstra$ 算法。

- **问题**：即使所有边的权重都是非负的，这种方法也不能保证 $Dijkstra$ 算法能够产生正确的最短路径。

  原因是加权可能会改变边之间的相对权重，导致原本由于负权重边而形成的最短路径被错误地计算。

##### 引理 1：存在负权重环时最短路径不存在
- **描述**：如果从顶点 $v$ 到顶点 $t$ 的某条路径包含了一个负权重环 $W$ ，那么就不存在从 $v$ 到 $t$ 的最短路径。
- **证明**：如果存在这样一个负权重环 $W$ ，那么我们可以通过不断地绕行 $W$ 来构造一个任意负长度的从 $v$ 到 $t$ 的路径。因为每次绕行 $W$ 都会使路径的总权重减少，这意味着路径的权重可以无限减小，所以不存在一个固定的“最短”权重。

##### 引理 2：无负权重环时存在简单最短路径
- **描述**：如果图 $G$ 中没有负权重环，那么存在一条从 $v$ 到 $t$ 的最短路径，这条路径是简单的（即不包含环），并且包含的边数不超过 $n - 1$（其中 $n$ 是图中顶点的数量）。

- **证明**：
  - 在所有从 $v$ 到 $t$ 的最短路径中，考虑使用边数最少的那条路径 $P$ 
  
  - 如果 $P$ 包含一个有向环 $W$ ，我们可以移除 $P$ 中对应 $W$ 的部分而不增加路径的长度。
  
    因为如果 $W$ 不是负权重环，移除 $W$ 后路径的权重不会增加，这样就得到了一条同样权重但边数更少的路径。
  
  - 重复这个过程，直到没有环为止，最终得到的路径就是一条简单最短路径。

##### 算法流程

**状态转移方程：**

$OPT(i,v)$ ：使用**不超过** $i$ 条边的条件下，从顶点 $v$ 到终点 $t$ 的最短路径的长度

情况 1：最短路径使用不超过 $i-1$ 条边

情况 2：最短路径恰好使用 $i$ 条边。

 $OPT(i,v)=\min \{OPT(i-1,v), \min\{OPT(i-1,w)+ l_{vw}\}\}$

```c++
SHORTEST-PATHS(V, E, ℓ, t) 
FOREACH node v ∈ V :
	M [0, v] ← ∞.
M [0, t] ← 0.
FOR i = 1 TO n – 1
	FOREACH node v ∈ V :
		M [i, v] ← M [i – 1, v].
		FOREACH edge (v, w) ∈ E :
			M [i, v] ← min { M [i, v], M [i – 1, w] + ℓvw }
```

