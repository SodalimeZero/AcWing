### 编辑距离

#### **定义**

针对两个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。

##### 操作类型

1. **插入**：在一个字符串中插入一个字符。
2. **删除**：从一个字符串中删除一个字符。
3. **替换**：将一个字符串中的一个字符替换为另一个字符。

##### 间隔罚分和不匹配罚分

- **间隔罚分 ( $\delta$ )**：插入或删除一个字符的代价。
- **不匹配罚分 ( $\alpha_{pq}$ )**：将字符 $p$ 替换为字符 $q$ 的代价。

#### 动态规划解题思路

##### 状态表示 $dp[i][j]$

集合：所有把 $a$ 中的前 $i$ 个字母变成 $b$ 中前 $j$ 个字母的集合的操作集合
属性：所有操作中操作次数最少的方案的操作数

##### 状态计算

**状态划分**：以对 $a$ 中的第 $i$ 个字母操作不同划分

1. 在该字母之后添加一个字母之后变得相同，说明没有添加前 $a$ 的前 $i$ 个已经和 $b$ 的前 $j-1$ 个已经相同
   $dp[i][j]=dp[i][j-1]+1$
2. 删除该字母
   删除该字母之后变得相同，说明没有删除前 $a$ 中前 $j-1$ 已经和 $b$ 的前 $j$ 个已经相同
   $dp[i][j]=dp[i-1][j]+1$
3. 替换该字母
   替换说明对应结尾字母不同，则看倒数第二个
   $dp[i][j]=dp[i-1][j-1]+1$
4. 啥也不做
   对应结尾字母相同，直接比较倒数第二个
   $dp[i][j]=dp[i-1][j-1]$

综上，有如下的转移方程

$dp[i][j]=\left\{\begin{matrix}
 dp[i][j-1]+1&&添加一个字母后匹配\\
 dp[i-1][j]+1&&删除\\
dp[i-1][j-1]+1&&替换\\
  dp[i-1][j-1]&&match，啥也不做
\end{matrix}\right.$

算法的时间、空间复杂度均为 $O(mn)$ ， $m, n$ 分别为字符串 $a, b$ 的长度

#### Hirschberg算法

降低空间复杂度到 $O(m+n)$

$f(i,j)$ 表示从 $(0,0)$ 走到 $(i,j)$ 的路径

**引理：对于所有的 $i,j$，$f[i][j]=dp[i][j]$**

**证明**

- **基础案例**：$𝑓(0,0)=dp(0,0)=0$

- **归纳假设**：假设对于所有 $𝑖' +𝑗'<𝑖+𝑗$ 的情况，$𝑓(𝑖',𝑗')=dp(𝑖',𝑗')$ 成立。

- **归纳步骤**：考虑到达 $(𝑖,𝑗)$ 的最短路径的最后一个边。

  这个边可以来自三个可能的前一个状态：$(𝑖−1,𝑗−1)$、$(𝑖−1,𝑗)$或 $(𝑖,𝑗−1)$

  这意味着，到达 $(i,j)$ 的最短路径可以通过以下三种操作之一到达：

  1. 从 $(i-1,j-1)$ 替换字符（代价为 $\alpha_{x_i,y_{j}}$ ）
  2. 从 $(𝑖−1,𝑗)$ 删除字符（代价为 $\delta$ ）
  3. 从 $(𝑖,𝑗−1)$ 插入字符（代价为 $\delta$ ）

因此，$𝑓(𝑖,𝑗)$ 可以表示为： $𝑓(𝑖,𝑗)=min⁡\{\alpha_{x_i,y_{j}}+𝑓(𝑖−1,𝑗−1),\delta+𝑓(𝑖−1,𝑗),\delta+𝑓(𝑖,𝑗−1)\}$

根据归纳假设，我们可以将 $f$ 替换为 $dp$ ： $𝑓(𝑖,𝑗)=min⁡\{\alpha_{x_i,y_{j}}+dp(𝑖−1,𝑗−1),\delta+dp(𝑖−1,𝑗),\delta+dp(𝑖,𝑗−1)\}$

$f(i,j)=dp(i,j)$

这证明了引理，即 $𝑓(𝑖,𝑗)$ 确实等于 $𝑂𝑃𝑇(𝑖,𝑗)$ ，对于所有的 $i, j$

**定义 $g(i, j)$ **

- 定义 $g(i, j)$ 为从点 $(i, j)$ 到终点 $(m, n)$ 的最短路径长度
- 通过反转边的方向和交换起点 $(0,0)$ 和终点 $(m, n)$ 的角色，可以计算 $g(i, j)$ 
- 同样，可以计算任意 $j$ 的 $g(\cdot, j)$ ，其时间复杂度和空间复杂度与 $f(\cdot, j)$ 相同

**观察**

1. 使用点 $(i, j)$ 的最短路径长度是 $f(i, j) + g(i, j)$ 
2. 设 $q$ 是使得 $f(q, n / 2) + g(q, n / 2)$ 最小的索引。那么，存在一条从 $(0, 0)$ 到 $(m, n)$ 的最短路径，它通过点 $(q, n / 2)$。

**分治策略**

- **划分（Divide）**：找到索引 $q$ ，使得 $f(q, n / 2) + g(q, n / 2)$ 最小；将节点 $i-j$  作为解决方案的一部分保存下来。
- **合并（Conquer）**：递归地计算每个部分的最优对齐。

##### 算法流程

1. **初始化**：定义 $f(i, j)$  和 $g(i, j)$ ，它们分别代表从**起点到点 $(i, j)$** 和**从点 $(i, j)$ 到终点**的最短路径长度。
2. **计算 $f,g$ **：使用动态规划算法计算 $f(\cdot, j)$ \) 和 \( $g(\cdot, j)$ ，对于每个 $j$
3. **寻找分割点**：在 $f,g$ 的计算结果中，找到使得 $f(q, n / 2) + g(q, n / 2)$ 最小的 $q$ 
4. **递归求解**：将问题分为两部分，一部分是计算从 $(0,0)$ 到 $(q, n/2)$ 的最优对齐，另一部分是计算从 $(q, n/2)$ 到 $(m,n)$ 的最优对齐。递归地解决这两个子问题。
5. **合并结果**：将两个子问题的最优对齐结果合并，得到整个问题的最优对齐。

