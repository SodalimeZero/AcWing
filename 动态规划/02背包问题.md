## 02 背包问题

有 $N$ 种物品和一个容量是 $V$ 的背包，每种物品都有**无限件**可用。

第 $i$ 种物品的体积是 $v_i$ ，价值是 $w_i$

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出最大价值。

## 输入格式

第一行两个整数， $N，V$ ，用空格隔开，分别表示物品种数和背包容积。

接下来有 $N$ 行，每行两个整数 $v_i,w_i$ ，用空格隔开，分别表示第 $i$ 种物品的体积和价值。

## 输出格式

输出一个整数，表示最大价值。

## 数据范围

$0< N,V\le 1000$

$0< v_i,w_i\le 1000$

## 解题思路

### 朴素做法

对于第 $i$ 个物品，体积要求为 $j$ 时，求所能存储的最大价值 $P[j]$ ，有两种情况：

- 放入该物品
  - 要放入该物品，假设放入 $num$ 个，就要把放该物品的空间 $V_i\times num$ 腾出来，其他物品能占的空间为 $j-V_i\times num$ ，对应的能存储的最大价值为 $P[j-V_i\times num] + W_i\times num$ . 
- 不放入该物品
  - 那就是对于前 $i-1$ 个物品，空间为 $j$ 时的最大价值，也就是 $P[j]$ .
  
时间复杂度为 $O(nm^2)$ ，理所当然 TLE 了。

```cpp
for (int i = 0; i < n; i++) {
    scanf("%d%d", &v, &w);
    for (int j = v; j <= m; j++) {
        for (int num = 1; num * v <= j; num++) {
            p[j] = max(p[j], p[j - v * num] + w * num);  
        }
    }
}
```

### 进阶做法

当体积要求为 $j$ 时，

> $p[j - v] = max(p[j - v], p[j - 2 * v] + w, p[j - 3 * v] + 2 * w, \dotsm)$

而我们想要的最大的 $p[j]$ 

> $p[j]= max(p[j],\ p[j - v] + w,\ p[j - 2 * v] + 2 * w,\ p[j - 3 * v] + 3 * w)$

整理以上两个柿子可得， $p[j] = max(p[j], p[j-v]+w)$

```cpp
#include<iostream>
using namespace std;

const int N = 1010;
int p[N];

int main()
{
    int n, m;
    cin >> n >> m;
    int v, w;
    
    for (int i = 0; i < n; i++) {
        scanf("%d%d", &v, &w);
        for (int j = v; j <= m; j++) {
            p[j] = max(p[j], p[j - v] + w);  
        }
    }
    printf("%d", p[m]);
    return 0;
}
```
