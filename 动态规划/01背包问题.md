## 01 背包问题

有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。

第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$ .

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出最大价值。

## 输入格式

第一行两个整数， $N，V$ ，用空格隔开，分别表示物品数量和背包容积。

接下来有 $N$ 行，每行两个整数 $v_i,w_i$ ，用空格隔开，分别表示第 $i$ 件物品的体积和价值。

## 输出格式

输出一个整数，表示最大价值。

## 数据范围

$0<N,V≤1000$

$0<v_i,w_i≤1000$

## 解题思路

用数组 $V$ 和 $W$ 分别存储这些物品的体积和价值，二维数组 $P$ 表示对于前 $i$ 个物品，体积要求为 $j$ 时，能够存储的最大价值。

对于第 $i$ 个物品，求最大的 $P_{i,j}$ ，有两种情况：

- 放入该物品
  - 要放入该物品，就要把放该物品的空间 $V_i$ 腾出来，其他物品能占的空间为 $j-V_i$ ，对应的能存储的最大价值为 $P_{i-1,j-V_i}$ . 
  - 再加上这个物品的价值，此时背包总价值为 $P_{i-1,j-V_i}+W_i$ .
- 不放入该物品
  - 那就是对于前 $i-1$ 个物品，空间为 $j$ 时的最大价值，也就是 $P_{i-1,j}$ .

综上，代码为

```cpp
for (int i = 1; i <= n; i++) { // 有i个物品，最大体积要求为j
    for (int j = 1; j <= m; j++) {
        int ori_weight = p[i - 1][j]; // 不选第 i 个
        // 当j小于第i个物品的体积时，一定不能选第i个物品
        if (j >= v[i]) {
            int after_weight = p[i - 1][j - v[i]] + w[i];
            p[i][j] = max(ori_weight, after_weight);
        } else {
            p[i][j] = ori_weight;
        }
    }
}
```

### 优化为一维数组

我们定义的状态 $P_{i,j}$ 可以求得任意合法的 $i$ 与 $j$ 最优解，但题目只需要求得最终状态 $P_{n,m}$ ，因此我们只需要一维的空间来更新状态

此时 $P_j$ 表示当体积容量为 $j$ 时，背包的最大价值，进而

对于第 $i$ 个物品，求最大的 $P_{j}$ ，有两种情况：

- 放入该物品
  - 要放入该物品，就要把放该物品的空间 $V_i$ 腾出来，其他物品能占的空间为 $j-V_i$ ，对应的能存储的最大价值为 $P_{j-V_i}$ . 
  - 再加上这个物品的价值，此时背包总价值为 $P_{j-V_i}+W_i$ .
- 不放入该物品
  - 那就是对于 $i-1$ 个物品，空间为 $j$ 时的最大价值，也就是 $P_{j}$ .
  
此时我们发现，如果我们还是正序，则有 $P_{较小体积}$ 更新到 $P_{较大体积}$ ，则有可能本应该用第 $i-1$ 轮的状态却用的是第 $i$ 轮的状态。

因此此时要进行 **逆序** 排列。

```cpp
for (int i = 1; i <= n; i++) { // 有i个物品，最大体积要求为j
    for (int j = m; j >= v[i]; j--) {
        // 一维数组：最大体积要求为j时，最大的价值是多少？？
        p[j] = max(p[j], p[j - v[i]] + w[i]); 
        // 当我想要第i个物品时，我必须要有v[i]空间，因此此时的体积要求是j-v[i]
    }
}
```

### 优化存储空间

我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。

因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。

```cpp
for (int i = 1; i <= n; i++) {
    int v, w;
    scanf("%d%d", &v, &w);
    for (int j = m; j >= v; j--) {
        p[j] = max(p[j], p[j - v] + w);
    }
}
```
