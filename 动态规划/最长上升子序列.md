## 最长上升子序列

给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。

## 输入格式

第一行包含整数 $N$

第二行包含 $N$ 个整数，表示完整序列。

## 输出格式
输出一个整数，表示最大长度。

## 数据范围

$1\le N\le 1000$

$−10^9≤数列中的数≤10^9$

## 输入样例

```
7
3 1 2 1 8 5 6
```

## 输出样例：

```
4
```

## 解题思路

状态表示：我们用数组 $f[i]$ 表示对于第 $i$ 个整数，在它之前的最长上升子序列的长度

以给到的 ```3 1 2 1 8 5 6``` 为例

可以得到， $f[0]=1, f[1]=1, f[2]=2, f[3]=2, f[4]=2, f[5]=3, f[6]=4$

其实我们可以看到，当 $value_j < value_{i+1}, j\in [0,i]$ 时，因为 $f[j]$ 就表示了之前的最长子序列的长度，所以 $f[i+1]$ 的值也就是再加1即可。

状态转移方程： $f[i] = max(f[j] + 1), j\in [0, i - 1]$

时间复杂度： $O(n^2)$

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;
int nums[N], f[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &nums[i]);
    }
    
    int maxValue = 1;
    for (int i = 1; i <= n; i++) {
        f[i] = 1;
        for (int j = 1; j <= i; j++) {
            if (nums[i] > nums[j]) {
                f[i] = max(f[i], f[j] + 1);
            } // 因为这里数组f[i]表示的是以i为结尾的最大子序列的长度，所以不需要去考虑nums[i] <= nums[j]的情况
        }
        maxValue = max(maxValue, f[i]);
    }
    printf("%d\n", maxValue);
    return 0;
}
```
