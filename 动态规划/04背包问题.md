## 04 背包问题

有 $N$ 种物品和一个容量是 $V$ 的背包。

第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

## 输入格式
第一行两个整数， $N，V$ ，用空格隔开，分别表示物品种数和背包容积。

接下来有 $N$ 行，每行三个整数 $v_i,w_i,s_i$ ，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。

## 输出格式
输出一个整数，表示最大价值。

## 数据范围

$0< N\le 1000$

$0< V\le 2000$

$0< v_i,w_i,s_i\le 2000$

## 解题思路

以下思路有参考[这篇博客](https://www.acwing.com/solution/content/20115/)

本题考查多重背包的二进制优化方法

[上一个问题](03背包问题.md)里有提到死拆，也就是把多重背包视作多个[01背包问题](01背包问题.md)来做

但是当物品的体积和数量都变多时，便不能每个都用单纯的拆成一个来表示了。

已知：

- 我们知道转化成01背包的基本思路就是：判断每件物品我是取了你好呢还是不取你好。
- 我们知道任意一个实数可以由二进制数来表示，也就是 $2^0, 2^1, \dotsm 2^k$ 其中一项或几项的和。
- 这里多重背包问的就是每件物品取多少件可以获得最大价值。

于是，我们需要思考，物品个数为 $s$ 时，我们可以把它拆成什么数字，使得 $s$ 可以被其唯一表示。

如```7 = 1 + 2 + 4```.

也可以这么理解：

要求在一堆苹果选出 $n$ 个苹果。我们传统的思维是一个一个地去选，选够 $n$ 个苹果就停止。这样选择的次数就是 $n$ 次

二进制优化思维就是：现在给出一堆苹果和10个箱子，选出 $n$ 个苹果。将这一堆苹果分别按照```1, 2, 4, ···, 1024```分到10个箱子里，那么由于任何一个数字 $x\in [1, 1023]$ 都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10 次。

这样利用二进制优化，时间复杂度就从 $O(n^3)$ 降到了 $O(n^2\log_{2}{S})$ .

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 2010;
int f[N];

struct good {
    int v; // 体积
    int w; // 价值
};

int main()
{
    vector<good> goods;
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        int v, w, s;
        cin >> v >> w >> s;
        for (int k = 1; k <= s; k = 2 * k) {
            s = s - k;
            goods.push_back({v * k, w * k});
        }
        if (s > 0) {
            goods.push_back({v * s, w * s});   
        }
    }
    
    for (auto good: goods) {
        for (int j = m; j >= good.v; j--) {
            f[j] = max(f[j], f[j - good.v] + good.w);
        }
    }
    printf("%d\n", f[m]);
    
    return 0;
}
```