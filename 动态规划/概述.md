### 动态规划

#### 基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；
2. 寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。
3. 按顺序求解每一个阶段的问题。

#### 带权区间调度算法

##### 运行时间分析

我们要证明记忆化版本的带权区间调度算法的运行时间为 $O(n \log n)$ 以下是详细的证明步骤：

1. 按结束时间排序

- 排序的时间复杂度为 $O(n \log n)$ ，可以使用归并排序或快速排序等高效排序算法。

2. 计算 $p[j]$ 数组

- 对于每个作业 $j$ ，使用二分查找计算 $p[j]$ . 每次二分查找的时间复杂度为 $O(n\log n)$

3. 记忆化计算最优解

- 对于 `M-COMPUTE-OPT(j)` 函数，每次调用的时间复杂度为 $O(1)$ 
- 每次调用时有两种情况：
  1. 返回已初始化的 $M[j]$ 值。
  2. 初始化 $M[j]$ 并进行两次递归调用。
  

我们引入一个进度度量 $\Phi$ 来表示数组 $M$ 中已经初始化的条目数：
- 初始时$\Phi = 0$
- 总共有 $n$ 个作业，因此 $\Phi \leq n $
- 每当进行一种情况2（初始化 $M[j]$ 并进行两次递归调用）时，$\Phi$ 增加1

由于每个 $M[j]$ 只会初始化一次，所以总共最多进行 $2n$ 次递归调用。每次调用的时间复杂度为$O(1)$，所以记忆化计算部分的总时间复杂度为 $O(n)$

总时间复杂度

结合以上各部分的时间复杂度：
- 排序：$ O(n \log n) $
- 计算 \( p \) 数组：$O(n \log n) $
- 记忆化计算最优解：$O(n)$

综合起来，总时间复杂度为：
$O(n \log n) + O(n \log n) + O(n) = O(n \log n) $

#### 最大子序列问题

**定义：** 在数列的一维方向找到一个连续的子数列，使该子数列的和最大

##### 求解步骤

1. **定义状态**：

    设 $dp[i]$ 表示以第 $i$ 个元素结尾的最大子数组和

2. **状态转移方程**：

    对于每个元素 $arr[i]$ ，我们有两个选择：

    - 将其加入前面的子数组（即 $dp[i−1]+arr[i]$ ）

    - 从它开始一个新的子数组（即 $arr[i]$ ）

    状态转移方程为： $dp[i] = \max(dp[i-1] + arr[i], arr[i])$ 

3. **初始状态**：

    $dp[0] = arr[0]$ 

4. **最终结果**：

    最大子数组和为 dpdpdp 数组中的最大值，即 $\text{max\_sum} = \max(dp[0], dp[1], \ldots, dp[n-1])$ 

##### 时间复杂度

每个元素只被处理一次，且每次处理的时间复杂度为 $O(1)$ .因此，总时间复杂度为 $O(n)$ 

#### 二维矩阵的最大子矩形和问题



#### 01背包问题

给定 $n$ 件物品，每件物品有一个重量和一个价值。目标是选择一些物品装入背包，使得总重量不超过 $W$ 的同时总价值最大。

动态规划算法在 $\Theta(nW)$ 的时间和空间内解决了包含 $n$ 件物品和最大重量 $W$ 的背包问题。

**动态规划表计算**

动态规划表 $M[i,w]$ 表示前 $i$ 件物品在最大重量为 $w$ 时的最大价值。表的填充规则如下：

1. 初始化：

    $M[0,w]=0$ 对于所有 $w$ ，即没有物品时的最大价值为0

    $M[i,0]=0$ 对于所有 $i$ ，即背包容量为0时的最大价值为0

2. 填充动态规划表：

    对于每个物品 $i$ 和每个可能的重量 $w$：

    - 如果物品 $i$ 的重量超过当前重量 $w$ ，则不选该物品：$M[i,w]=M[i−1,w]$ 
    - 否则，计算选该物品和不选该物品的最大价值：$M[i, w] = \max(M[i-1, w], M[i-1, w - w_i] + v_i)$

#### 硬币兑换问题

给定 $n$ 种硬币的面额 ${d_1, d_2, \ldots, d_n}$ 和一个目标值 $V$ ，找到凑出目标值所需的最少硬币数量（或者报告不可能凑出目标值）。

**步骤**

1. 初始化：

- 创建一个大小为 $V+1$ 的数组 $M$ ，并初始化为 $\infty$（表示该金额无法被凑出）。
- 设置 $M[0] = 0$ ，因为凑出金额 0 需要 0 个硬币。

2. 填充表格：

- 对于每个金额 $v$ 从 1 到 $V$，依次计算需要的最少硬币数。
- 对于每种硬币面额 $d_i$ ，如果当前金额 $v$ 大于等于 $d_i$ ，则更新 $M[v]$ 为当前值和 $M[v - d_i] + 1$ 中的较小值。这一步表示如果选择了面额为 $d_i$ 的硬币，那么需要的硬币数为凑出金额 $v - d_i$ 的最少硬币数再加 1

3. 结果：

- 如果最终 $M[V]$ 仍然为 $\infty$ ，则表示无法凑出金额 $V$ ；否则，返回 $M[V]$ ，即凑出金额 $V$ 所需的最少硬币数。

### 总结

动态规划（Dynamic Programming，DP）是一种强大的算法技术，通过将复杂问题分解为更小的子问题来解决。这种方法特别适用于需要优化的问题，其中解决方案可以通过解决较小的子问题来构建。

#### 动态规划的大纲

1. **定义一组子问题**：
   - 将原问题分解为更小、更易处理的子问题。
   - 每个子问题代表整体问题的一部分。

2. **从子问题的解中构建原问题的解**：
   - 确保原问题的解可以从子问题的解中得出。
   - 使用递归关系将问题的解表示为较小问题的解。

3. **子问题的自然排序**：
   - 组织子问题，使其可以从“最小”到“最大”依次解决。
   - 这种排序确保在解决一个子问题时，它依赖的所有较小子问题的解已经知道。

#### 动态规划的技术

1. **二元选择**：加权区间调度问题
   - 每个决策涉及两种选择，通常是包含或不包含某个项目。
   - 示例：加权区间调度问题，每个作业要么被包括要么不被包括。

2. **多路选择**：分段最小二乘法
   - 每个决策涉及多种选择。
   - 示例：分段最小二乘法，通过选择最佳的分段点来优化每段的拟合。

3. **添加新变量**：背包问题
   - 添加一个额外的维度来捕获解的状态。
   - 示例：0/1 背包问题，每个项目要么被包括要么不被包括，解的状态取决于当前的重量和价值。

4. **区间**：RNA二级结构
   - 解涉及考虑范围或区间。
   - 示例：RNA二级结构预测，最优结构由不同区间之间的相互作用决定。

#### 自顶向下 vs. 自底向上的动态规划

- **自顶向下（备忘录法）**：
  - 从原问题开始，通过递归将其分解为子问题。
  - 存储子问题的结果（备忘录）以避免重复计算。
  - 优点：实现简单、易于理解，特别适用于不需要解决所有子问题的情况。
  - 缺点：由于递归调用，可能有较高的内存开销。

- **自底向上（递推法）**：
  - 从最小的子问题开始，逐步解决并合并它们以解决更大的子问题。
  - 使用表格（数组或矩阵）存储结果，从基础构建解决方案。
  - 优点：避免递归，通常使用更少的内存，可以更高效。
  - 缺点：实现不如自顶向下直观，特别是对于有复杂依赖关系的子问题。

### 示例问题

1. **加权区间调度问题**：
   - 基于最大权重的兼容作业来定义子问题。
   - 使用二元选择决定是否包括每个作业。

2. **分段最小二乘法**：
   - 基于到某点数据的最佳线段拟合来定义子问题。
   - 使用多路选择确定最佳的分段点。

3. **0/1 背包问题**：
   - 基于一定重量容量下可达到的最大价值来定义子问题。
   - 使用额外的变量来跟踪剩余容量。

4. **RNA二级结构预测**：
   - 基于RNA子串的最优结构来定义子问题。
   - 使用区间选择确定最佳配对。
