### 快速排序

时间复杂度: $O(nlog_{2}{n})$

不稳定

主要思想：分治

**解题思路**
1. 确定分界点：一般为左端点/右端点/中间点/随机，这里确定好之后，拿去比较的是这个点的值，而不是下标。因为随着排序的推进，下标对应的数据会随时变化。
   
2. 调整区间：让小于等于 $x$ 的在 $x$ 左边，大于 $x$ 的在 $x$ 右边
   
3. 递归处理左右两端，排序

```c++
void quick_sort(int q[], int i, int j)
{
    if(i >= j) {
        return;
    }
    int temp = q[i + j >> 1]; // 确定分界点
    int s = i - 1, t = j + 1;
    while(s < t){
        do s++; while(q[s] < temp); // 必须是do while循环，如果是while循环的话要更改判断条件
        do t--; while(q[t] > temp);
        if(s < t)
            swap(q[s], q[t]);
    }
    quick_sort(q, i, t);
    quick_sort(q, t + 1, j);
}
```