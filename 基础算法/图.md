### 1. 图的连通性问题

是否存在 $s$ → $t$ 的路径？若存在，最短路径长度是多少？

可以用广度优先算法解决这个问题

#### 广度优先算法

图用邻接矩阵表示时，时间复杂度为 $O(n^2)$ ，实际运行时间为 $O(m+n)$ 

BFS 算法找到的路径是从起点开始的最短合法路径。换言之，这条路径所包含的边数最小。

#### 强连通性

节点 $u$ 和 $v$ 是相互可达的

如果图中节点都是相互可达的，那就称这个图为**强连通图**

#### 判断图是否为强连通图

时间复杂度： $O(m+n)$

1. **遍历**：从任意一个顶点开始，使用广度优先搜索（BFS）遍历图，记录访问过的顶点。
2. **检查所有顶点**：确保遍历过程中访问了所有顶点。如果没有访问到所有顶点，那么图不是强连通的。
3. **反向遍历**：对图进行反向操作，然后再次使用BFS从同一个顶点开始遍历反向图。
4. **验证强连通性**：如果反向遍历也能访问到所有顶点，那么原图是强连通的。

#### 强连通分量

在有向图中，如果一个顶点集合 $S$ 中的任意两个顶点 $u$ 和 $v$ 都存在从  $u$   到  $v$  的有向路径和从  $v$  到  $u$  的有向路径，那么这个顶点集合 $S$ 就是一个强连通分量。

简单来说，强连通分量是图中的一个最大的子图，该子图中的任意两个顶点都是相互可达的。

可以在 $O(m+n)$ 内找到所有的强连通分量

### 2. 二分图

如果图 $G$ 的顶点可以被分为两个不相交的子集 $U$ 和 $V$ ，使得 $G$ 中的每条边的两个顶点分别属于 $U$ 和 $V$ ，那么图 $G$ 就是二分图。

**二分图的性质**

- 环的长度为偶数
- BFS遍历图，可以确定图是否为二分图。
    - 如果BFS过程中没有发现连接同一层顶点的边，那么图是二分的：用两种不同的颜色对顶点进行着色，白色代表奇数层的节点，蓝色代表偶数层的节点。由于BFS保证了每条边连接的是相邻层次的节点，所以这种着色方案保证了没有两个相邻的节点会有相同的颜色，从而证明了图G是二分图
    - 如果发现了这样的边，则图不是二分的，并且至少包含一个奇数长度的环：考虑一个环，它首先沿着边从x到y，然后沿着从y到z的路径，最后沿着从z到x的路径。这个环的长度是1（x到y的边）加上两倍的 $j - i$ 。因为x和y在同一层Lj，而z在Li，所以j - i是x或y到z的路径长度。由于这个环包含了x到y的边，再加上两次从z到x或y的路径，总长度是奇数。
- 一个图 $G$ 是二分图当且仅当它不包含奇数长度的环。（证明其充要性）

### 3. 有向无环图DAG

**定义**：有向无环图是一种有向图，其中不存在任何从某个顶点出发通过一系列有向边再次回到该顶点的路径。换句话说，有向无环图中不存在任何长度大于0的环。

**拓扑排序定义**：

- 拓扑排序是DAG的顶点的一种线性排序，使得对于每一条有向边 $(u, v)$，顶点 $u$ 在排序中出现在顶点 $v$ 之前。
- 拓扑排序并不唯一，一个DAG可能有多个不同的拓扑排序。

**证明：若 $G$ 有拓扑排序，那么 $G$ 是DAG.**

- 假设 $G$ 有拓扑排序 $v_1, v_2, \dotsm, v_n$ 且含有一个环 $C$

- 设 $v_i$ 是环 $C$ 里索引值最小的节点，$v_j$ 是 $v_i$ 前面的节点，则存在边 $(v_j, v_i)$

- 根据上述选择可知 $i < j$

- 又因为边 $(v_j, v_i)$且 $v_1, v_2, \dotsm, v_n$ 为一个拓扑排序，则可得 $j < i$

- 矛盾

**求解拓扑排序**

**证明时间复杂度为 $O(m+n)$  **

- Kahn's Algorithm（基于入度的广度优先搜索）

    - 计算图中所有顶点的入度

    - 将入度为0的顶点加入到队列

    - 从队列中取出一个节点，将它加入结果序列，并将其所有邻居的入度减 1。如果某个邻居的入度变为 0，将其加入队列。

    - 重复上述步骤，直到队列为空。


**证明：若图为有向无环图，那么它有一个拓扑排序**

- 节点数 $n$ 为1时，假设成立

- 当 $n > 1$ 时，假设对于所有节点数小于 $n$ 的DAG，都存在拓扑排序。我们现在考虑一个具有 $n$ 个顶点的图

    - 我们可以找到一个入度为 0 的顶点 $v$ 

    - 考虑从 $G$ 中删除顶点 $v$  以及与 $v$  相关的所有边，得到的子图记为 $G - \{ v \}$ ，$G - \{ v \}$ 仍然是一个DAG，因为删除顶点和相关边不可能产生新的环

    - 根据归纳假设，子图 $G - \{ v \}$ 中存在拓扑排序。设这个拓扑排序为 $v_1,v_2,…,v_{n−1}$ 

    - 将顶点 $v$ 放在拓扑排序的最前面，然后将 $G - \{ v \}$ 的拓扑排序 $v_1,v_2,…,v_{n−1}$ 依次排列在后面。

        得到的排序为 $v, v_1,v_2,…,v_{n−1}$ 

    - 新的排序是有效的拓扑排序，因为顶点 $v$ 没有入边，所以它可以放在排序的最前面，并且 $G - \{ v \}$  的拓扑排序保证了所有其他顶点的有向边关系。

### 4. 生成树

**定义：** $H=(V, T)$ 为图 $G=(V, E)$ 的一个子图。若 $H$ 是无环且联通的，就成 $H$ 是 $G$ 的一个生成树。

**割**：将图中节点分割为两部分

**割集**：只包含割 $S$ 中一个节点的连边集合

若环和割集有交集，那这个交集中边的数目一定是偶数。（因为环是闭合的）

**性质：**

1. **$H$ 是 $G$  的一个生成树**

2. **$H$ 是无环的并且连通的**

3. **$H$ 是连通的并且有 $|V|-1$ 条边**

    根据树的性质，一个连通的无环图（即树）总是恰好有  $|V|-1$ 条边，其中  $|V|$ 是节点的数量。

    因为树是一种最节省边的连通图，每增加一个节点，就需要增加一条边来保持连通性。

4. **$H$ 是无环的并且有 $|V|-1$ 条边**

5. **$H$ 是最小连通图**

    如果从 $H$ 中移除任何一条边都会使其失去连通性，那么 $H$ 是最小连通图。

    如果 $H$ 有少于  $|V|-1$  条边，它将不会连通；如果它有更多边，它将不是无环的。

6. **$H$ 是最大无环图**

    如果向 $H$ 添加任何一条边都会创建一个环，那么 $H$ 是最大无环图。

### 5. 最小生成树

**定义**：给定一个带权重的连通无向图  $G = (V, E)$ 后，从所有可能的生成树中选取的一个特殊生成树。

这个特殊生成树满足以下条件：

1. **包含所有节点**：最小生成树必须**包含原图中所有节点**，即 $V$ 中的每个节点都是图的一部分。
2. **连通性**：最小生成树必须是连通的，即图中任意两个节点之间都存在路径相连。
3. **无环**：最小生成树是无环的，这意味着树中不存在闭合路径。
4. **最小化总权重**：最小生成树的边的权重总和是所有生成树中最小的。这里的权重 $ c_e $ 是指连接任意两个节点 $u$ 和 $v$ 的边 $ e = (u, v) $ 的成本或权重。

**凯莱定理**：在有 $n$ 个节点的完全图中，存在 $n^{n-2}$ 个不同的生成树。

**解释**：

1. **完全图**：一个完全图是指图中的每对不同的节点之间都有一条边相连。对于有 $n$ 个节点的完全图，通常记作 $K_n$
2. **证明概述**：考虑从任意一个节点开始进行深度优先搜索（DFS），在完全图中，除了起始节点外，每个节点都有 $n-1$ 条边可以走。在遍历过程中，每选择一条边，就相当于选择了生成树中的一条边。由于生成树有  $n-1$ 条边，所以总共有 $(n-1)^{n-1}$  种不同的DFS遍历方式。
3. **定理的推导**：然而，上述的 $(n-1)^{n-1}$ 计算了所有可能的树形结构，包括了同一棵树的不同遍历。为了得到不相似的树的数量，我们需要除以 $(n-1)!$ 即树中节点的全排列数，代表了同一棵树的不同遍历方式。

### 6. 最短路径问题

#### Dijkstra算法（贪心）

时间复杂度： $O(n^2)$ 

松弛操作：比起原来的路径，找到了一条距离更短的路，则将原来点的距离更新为新的距离。

**定义：**在加权图中找到单个源点到所有其他顶点的最短路径。

**算法步骤：**

1. **初始化**：将源点到自己的距离设为0，其他所有顶点到源点的距离设为无穷大（表示尚未找到路径）。
2. **设置未访问集合**：所有顶点最初都在未访问集合中。
3. **选择最小距离顶点**：从未访问集合中选择一个具有最小距离的顶点，称为当前顶点。
4. **更新相邻顶点**：对于当前顶点的每一个邻居，如果通过当前顶点到邻居的距离小于已知的距离，则更新邻居的最短路径估计值。
5. **移动到已访问集合**：将当前顶点从未访问集合移动到已访问集合。
6. **重复步骤3-5**：重复执行选择、更新和移动步骤，直到所有顶点都被访问，或者找到目标顶点。
7. **结束**：算法结束时，每个顶点的最短路径估计值就是从源点到该顶点的最短路径长度。

**优化**

1. 维护每个未探索节点的当前最短路径估计值，$π[v]=min(π[v],π[u]+w(u,v))$ ，避免每次都从头计算最短路径估计值
2. 使用最小优先队列选择未探索节点，快速找到并处理当前最小的 $π[v]$ ，确保算法高效运行

