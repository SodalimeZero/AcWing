### 分治

分治算法分为三步：划分、解决问题、合并

### 归并排序

时间复杂度为 $O(nlog_2n)$

#### 排序下界定理
- 任何确定性的基于比较的排序算法在最坏情况下必须至少执行 $O(n \log n)$ 次比较。

#### 证明
- **信息论方法**：使用信息论的概念来证明。

1. **假设**：假设数组由 n个不同的值 $a_1$ 到 $ a_n$ 组成。
2. **最坏情况下的比较次数**：在最坏情况下，排序算法需要执行的比较次数等于剪枝比较树的高度 $h$。
3. **比较树的高度**：一个高度为$h$的二叉树最多有$2^h$个叶子。
4. **不同排序的数量**：有 $n!$ 种不同的排序方式，这意味着需要 $n!$ 个可到达的叶子来表示所有可能的排序。
5. **比较次数与排序数量的关系**：由于有 $n!$  种不同的排序，而树的高度 $h$ 决定了最多可以有  $2^h$ 个叶子，因此必须有 $ 2^h \geq n! $
6. **计算下界**：对不等式 $2^h \geq n!$ 取以 2 为底的对数，得到 $ h \geq \log_2(n!) $. 使用斯特林公式近似$\log_2(n!)$，可以得到$ h \geq n \log_2(n) - n$
7. **简化**：由于 $n \log_2(n)$ 是主要项，且 $n$ 够大时其余项相对于  是$O(\log_2(n))$较低阶的项，可以忽略。因此，我们有 $h=O(n \log_2 n)$
8. **结论**：这意味着任何基于比较的排序算法在最坏情况下必须至少进行 $O(n \log n)$ 次比较。



**例题**

给定一个单链表，随机统一的重新排列其节点。假设有完美的随机数生成器，那么时间复杂度为 $n \log n$ ， 空间复杂度为 $\log n$ .

### 逆序对计算

假设数组 $A$ 和 $B$ 为排序之后的子数组，结果数组为 $C$ .

在合并过程中，比较 $A$ 和 $B$ 中的元素，讲较小的元素加到结果数组 $C$ 中：

- 如果 $A[i] \le B[j]$ 
    - $A[i]$ 不会与 $B$ 中任何元素构成逆序对，因为 $A[i]$ 已经是较小的元素。
    - 将 $A[i]$ 添加到 $C$  中，并移动指针 $i$

- **如果 $A[i] > B[j]$**：

    - $A[i]$ 将与 $B$ 中的每个元素 $B[j]$ 及其前面的元素形成反转对，因为 $A[i]$  比这些元素大。

    - 反转对的数量为 $A$ 中剩余元素的数量，即 $mid - i + 1$（其中 $mid$ 是左子数组的结束位置）。

    - 将 $B[j]$ 添加到 $C$ 中，并移动指针 $j$

### 快速排序

给定数组 $a_1, a_2, \dotsm , a_n$ ，在快速排序过程中，$a_1$ 和 $a_n$ 会被比较的概率为 $2/ n$ 

为了证明随机化快速排序的期望比较次数为 \(O(n \log n)\)，我们可以通过分析快速排序过程中比较的概率以及比较的次数来进行证明。

#### 二叉搜索树（BST）表示
在随机化快速排序过程中，我们可以将每次选择的主元（pivot）看作是构建二叉搜索树的节点。排序过程中进行的比较可以理解为在构建二叉搜索树时进行的比较。

#### 比较的发生条件
- 对于任意两个元素 \(a_i\) 和 \(a_j\)（假设 \(i < j\)），它们会被比较当且仅当其中一个是另一个的祖先。这是因为在快速排序中，主元将数组分为左右两部分，之后的排序是在这些子数组中递归进行的。
- 因此，\(a_i\) 和 \(a_j\) 会在某一轮排序中被比较的条件是：在它们之间的任一元素没有被选择为主元。

#### 比较的概率
- \(a_i\) 和 \(a_j\) 之间没有被选择为主元的元素共有 \(j - i - 1\) 个。
- 在随机化快速排序中，每一轮选择主元是等概率的，因此在数组 \([i, j]\) 中选择 \(a_i\) 或 \(a_j\) 作为主元的概率为 \(2 / (j - i + 1)\)。

考虑所有可能的元素对 $(a_i, a_j)$ 的比较。对于每一对 $(a_i, a_j)$ ，其被比较的概率为 $2 / (j - i + 1)$

### Median of medians

好累，改天看

### 最近点对问题

输入 $n$ 个点的集合，输出具有最小欧几里得距离的两个点的对

#### 算法步骤

1. 分解：将点集分为两个子集
2. 递归：独立在两个子集上递归的应用算法
3. 合并：合并两个递归调用的结果，并在两个子集间的点中找到最近点对





