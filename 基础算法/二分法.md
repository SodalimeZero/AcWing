## 整数二分

二分的本质不是单调性：有单调性一定可以二分，二分不一定要有单调性。

本质：在区间 $[l,r]$ 中，存在一点 $p$ ，使得左侧区间 $[l, p]$ 不满足某一性质，而右侧区间 $[p+1, r]$ 满足这一性质。

也就是说，只要能找出这一性质，我们就可以用二分来做。

步骤：思考mid，写一个check函数，思考如何根据结果更新区间

```cpp
mid = (l + r + 1) / 2;
if (check(mid)) {
    l = mid; // mid点处满足这一性质，分界点一定在mid右侧
} else {
    r = mid - 1; // 分界点在mid左侧，由于mid处不满足这一性质，因此我们让r=mid-1
}
```

> 此时要有 $l+r+1$ 是因为，当 $r=l+1$ 时，如果不进行+1操作，此时 $mid$ 的值就等于 $l$ ，有可能导致一直循环

```cpp
mid = (l + r) / 2;
if (check(mid)) {
    r = mid; // mid点处满足这一性质，分界点一定在mid左侧
} else {
    l = mid + 1; // 分界点在mid右侧
}
```

## 例题

### 数的范围

给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。

对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回```-1 -1```。

### 输入格式

第一行包含整数 $n$ 和 $q$ ，表示数组长度和询问个数。

第二行包含 $n$ 个整数（均在 1∼10000 范围内），表示完整数组。

接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。

### 输出格式

共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 ```-1 -1```。

### 解题思路

这道题可以分两步来做，首先找区间的左端点，然后找区间的右端点。

找左端点，如果点 $mid$ 满足 $a[mid] >= k$ ，此时分界点一定在 $mid$ 左侧；否则，分界点在 $mid$ 右侧。

对于 ```1 2 2 3 3 4``` 来说，当 $k=1$ 时，$a[2] = 2 > k$ ，左侧分界点在坐标为2的点的左侧，因为左侧分界点的左侧的数字一定都是小于数字 $k$ 的。

代码如下：

```cpp
int left = 0, right = n - 1;
while (left < right) { // 先找左边界
    int mid = (left + right) >> 1;
    if (a[mid] >= k) {
        // 在左侧
        right = mid;
    } else {
        left = mid + 1;
    }
}
```

找右端点，如果点 $mid$ 满足 $a[mid] <= k$ ，此时分界点一定在 $mid$ 右侧；否则，分界点在 $mid$ 左侧。

代码如下：

```cpp
int left = 0, right = n - 1;
while (left < right) {
    int mid = (left + right + 1) >> 1;
    if (a[mid] <= k) {
        left = mid;
    } else {
        right = mid - 1;
    }
}
```