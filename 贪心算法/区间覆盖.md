## 区间覆盖
给定 $N$ 个闭区间 [ $a_i, b_i$ ] 以及一个线段区间[ $s, t$ ].

请你选择尽量少的区间，将指定线段区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出-1.

## 输入格式
第一行包含两个整数 $s, t$ ，表示给定线段区间的两个端点。

第二行包含整数 $N$ ，表示给定区间数。

接下来 $N$ 行，每行包含两个整数 $a_i, b_i$ ，表示一个区间的两个端点。

## 输出格式
输出一个整数，表示所需最少区间数。

如果无解，则输出-1.

## 数据范围
 $1≤N≤10^5$

 $−10^9≤a_i≤b_i≤10^9$

 $−10^9≤s≤t≤10^9$

**输入样例**
```r
1   5
3
-1  3
2   4
3   5
```
**输出样例**
```
2
```

## 解题思路
1. 将所有区间按照左端点进行从小到大的排序
2. 求出所有的包含线段区间[ $s, t$ ]的闭区间中，选择右端点最大的那个区间 $block$ ，同时把线段区间的左端点 $t$ 的值更新为 $block$ 的右端点的值

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main() {
    int start, end;
    scanf("%d%d", &start, &end);
    int n;
    cin >> n;

    for (int i = 0; i < n; i ++ ) {
        scanf("%d%d", &range[i].l, &range[i].r);
    }

    sort(range, range + n);

    int numOfBlocks = 0;
    bool flag = false; // 需要flag来进行标识，因为可能遍历完了所有数组但是还是没找到合适的
    
    for (int i = 0; i < n; i++) {
        int j = i, r = -2e9; // r记录当前的最大右端点值
        while (j < n && range[j].l <= start) {
            r = max(r, range[j].r);
            j++; // 顺序不能改
        }
        
        if (r < start) {
            numOfBlocks = -1;
            break;
        }
        
        numOfBlocks ++;
        if (r >= end) { // 已经走完了
            flag = true;
            break;
        }
        
        start = r;
        i = j - 1;
    }
    
    if (!flag) {
        numOfBlocks = -1;
    }
    printf("%d\n", numOfBlocks);   
    return 0;
}

```