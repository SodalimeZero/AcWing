## 耍杂技的牛

农民约翰的 $N$ 头奶牛（编号为 $1 \dotsm N$）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这 $N$ 头奶牛中的每一头都有着自己的重量 $W_i$ 以及自己的强壮程度 $S_i$.

一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

## 输入格式

第一行输入整数 $N$，表示奶牛数量。

接下来 $N$ 行，每行输入两个整数，表示牛的重量和强壮程度，第 $i$ 行表示第 $i$ 头牛的重量 $W_i$ 以及它的强壮程度 $S_i$.

## 输出格式

输出一个整数，表示最大风险值的最小可能值。

## 数据范围

$1≤N≤50000$

$1≤W_i≤10,000$

$1≤S_i≤1,000,000,000$

## 输入样例

```
3
10  3
2   5
3   3
```

## 输出样例

```
2
```

## 解题思路

按照一些大佬所说，做多了这种题就有了题感，就会觉得应该就是 $W_i + S_i$ 越大，这头牛就越在下面。

其实我觉得肉眼来看也是这样，不过关键就是如何证明了。

我们以第 $i$ 和 $i+1$ 个位置的牛为例，看这两头牛互换位置前后的风险值变化。

|   | $cow_i$  | $cow_{i + 1}$ |
| --- | --- | --- |
| 交换前 | $W_1 + W_2 + \dotsm+ W_{i-1} - S_i$ | $W_1 + W_2 + \dotsm+ W_{i} - S_{i+1}$ |
| 交换后 | $W_1 + W_2 + \dotsm+ W_{i-1} - S_{i+1}$ | $W_1 + W_2 + \dotsm+ W_{i-1} + W_{i+1} - S_i$ |

\
可以看到上面都包含有 $W_1 + W_2 + \dotsm+ W_{n-1}$，因而可以把上面的表格化简为

|           | $cow_i$          | $cow_{i + 1}$     | 最大风险|
| ---       |---               |---                | ---|
| 交换前     | $- S_i$          | $W_{i} - S_{i+1}$ | $max(W_{i} - S_{i+1}, \ -S_i)$ |
| 交换后     | $W_{i+1} - S_i$  | $- S_{i+1}$       | $max(W_{i+1} - S_i,\ -S_{i+1})$ |

要想让交换后的风险值比交换前小，也就是我们这个交换是有必要的，也就需要满足 

> $max(W_{i+1} - S_i,\ -S_{i+1})$  <  $max(W_i - S_{i+1},\ -S_{i})$

反证法：

如果 $max(W_{i} - S_{i+1}, \ -S_i) = -S_i$ ，就有 $max(W_{i+1} - S_i,\ -S_{i+1})$ < $-S_i$ ，那么可以看到 $W_{i+1} - S_i < -S_i$，这明显是不可能的，所以呢， $max(W_{i} - S_{i+1}, \ -S_i) = W_{i} - S_{i+1}$

同理可得， $max(W_{i+1} - S_i,\ -S_{i+1}) = {W_{i+1} - S_i}$

整理上式可得

> $W_{i+1} - S_i < W_i - S_{i+1}$
> 
> $W_{i+1} + S_{i+1} < W_i + S_i$

综上满足 $W_{i+1} + S_{i+1} < W_i + S_i$ 条件的时候，两头牛的位置是需要交换的，交换之后危险值降低，交换之后满足 $W_{i+1} + S_{i+1} > W_i + S_i$ ，因此，我们对其进行升序排序，得到的危险值就是最小的。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 50000;
typedef pair<int,int> PII;
PII cow[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int w, s;
        scanf("%d%d", &w, &s);
        cow[i].first = w + s;
        cow[i].second = w;
    }
    // 按照 w + s进行升序排序
    sort(cow, cow + n);
    
    long long res = -1e18, sum = 0, danger = 0;
    for (int i = 0; i < n; i++) {
        // 当前的危险系数
        danger = sum + cow[i].second - cow[i].first;
        res = max(danger, res);
        // sum保存之前所有的牛的总重量
        sum += cow[i].second;
    }
    printf("%d\n", res);
    return 0;
}
```